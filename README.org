* Gko Modules
These modules provide an interface for adding to, editing, and playing back an arbitary collection
of signals in time. The signals could be the audio output of some modules, it could be the output
from your MIDI keyboard, parameter automation...

The recording interface is the 'Gko' module. You can give it input/output ports by placing one or
multiple ~SIG~, ~4SIG~, or ~PLAY~ modules next to it.

- an editable timeline that plays an arbitrary collection of recorded signals
- compose by performing

making them suitable for live recording where one can not pause to click and clack.

** Gko
***  Selection
A version is simply a collection of looping buffers, or, in gko's terminology, a
collection of 'layers'.

The ~VERSION~ parameter adjusts which version ~GKO~ records and reads from.

If ~VERSION~'s position is between two versions, the behaviour will depend on the
"version transition" option.
- If set to  'smooth' it will output a weighted mix of both versions, allowing for smooth crossfading between versions.
- If set to 'discrete', the version will snap to the nearest version.
- If  set to 'sequence', the version will snap to the nearest version at the next
  clk step, and will also reset the play position of the version on transitioning.

The port directly under ~VERSION~ modulates the parameter, allowing for
interesting crossfade patterns, or voltage controlled version sequencing.

One may use multiple ~VERSIONs~ to sequence musical sections or, in the case ~GKO~
is capturing control voltage, a keygkor for control voltage.

Versions that have not recorded anything start with the layers of the version
before, so one may progress to the next version to leave behind a 'checkpoint',
that one may return to, or to just start developing a new version by altering the
current one.

*** Recording with GKO
When ~DELTA~ has moved a small threshold away from 12 o'clock, ~GKO~ will
start recording. The version that ~GKO~ chooses for recording, is the version that
is closest to the sum of the ~VERSION~ parameter and ~VERSION~ port.

If ~GKO~ detects a clock signal on the ~PHASE~ port, it will snap the  recording start
and end points to mutiples of the clock period.

Recording behaviour depends on whether ~GKO~ is in /global/ mode, or /layer/
mode. The ~DELTA_MODE~ button (up-right of ~DELTA~) toggles between these modes.
The upper LED in the delta section indicates its state.

Recording behaviour also depends on the direction of ~DELTA~'s rotation. If it
moves clockwise, it activates the /extend/ record mode. If ~DELTA~ moves
counter-clockwise, it activates /add/ mode. When ~DELTA~ returns to 12 o'clock,
~GKO~ finishes recording. The lower LED in the delta section indicates the
current recording mode.

The record and delta modes create four recording behaviours when combined.
**** /global/ and /extend/ mode
~GKO~ records the input signal into a new layer, and loops the layer when
~DELTA~ returns to 12 o'clock.

Used for dubbing a loop with elements that are longer than the current loop
length - for example, adding a chord progression for a repeating phrase.
**** /global/ and /add/ mode
~GKO~ records the input signal into a new layer with the same length as the
active layer. On reaching the end, it repeats the process.

Used for continuously recording multiple takes to audition and filter later
on, or record new layers continuously.

**** /layer/ and /extend/ mode
  ~GKO~ records the input signal into the active layer, and upon reaching the
  end, will continue recording as well as extend the active layer by looping
  the old contents.

  Used for creating variation at the xth repetition of a layer.
**** /layer/ and /add/ mode
~GKO~ records the input signal into the active layer and when it reaches the
loop end, it repeats the process.

Used for continuously overdubbing a layer.
*** Layer Attenuation
In all four mode combinations, if one twists further than the threshold
position, it affects the amplitude of previous layers at the current position,
or in other words, the 'attenuation power' of the recording. If delta mode is
/layer/, it only attenuates the active layer, if delta mode is /global/, it
attenuates all layers.

The attenuation power grows exponentially as ~DELTA~ twists, and when it reaches
a maximum, it will erase previous layers.

This attenuation behaviour allows for easily 'pushing back' previous layers in a
live-looping performance to create more movement. It also allows for editting
existing layers by re-recording certain parts. In the case there is no input
signal, it creates attenuation envelopes and when fully turned, erases parts of
previous layers.

*** Button Behaviour
Excluding the ~DELTA_MODE~ button, there are four other buttons on ~GKO~.

The button to the upper left of ~DELTA~ is the ~UNDO~ button. ~GKO~ keeps
track of states before and after engaging record modes, and ~UNDO~ recalls the
previous states. When one presses ~UNDO~ in a record mode, ~GKO~ will discard
any changes, and try again on the next loop start of the selected layer.

The ~PREV~ and ~NEXT~ buttons change the active layer, and the ~PLAY~ button
resets all layer positions to the beginning.
***

*** GKO Additional Uses Cases
**** Delay Unit
~GKO~ can function as a delay unit in the case /add/ mode is consistently on
in /layer/ mode. ~DELTA~ would control the feedback in this case.

One may use ~GKO-X~ to change the rate and offset of the delays to produce
cool delay effects.

**** Pitch Shifter
When one sets up ~GKO~ as a delay unit with a small layer size and adjusts
the ~RATE~ of ~GKO-X~, it will seem like the pitch of the sound is higher or
lower.

**** Advanced Sample & Hold / Sequencer
When one sets ~RATE~ to 0, ~GKO~ does not progress at all but still may record
and read signals. In this case, it acts as an advanced sample and hold module.
Adjusting the ~VERSION~ knob smoothly transitions between samples.

One may sequence samples in interesting ways using the ~VERSION~ modulation port.
**** Advanced 'MIDI' Looper
When ~GKO~ is expanding ~PLAY~, one may create interesting playback patterns
by recording some GATE, VOCT, and VEL signals, and varying or modulating the
~RATE~ and ~POS~ ports. One idea is to record a chord, and modulate ~RATE~ and
~POS~ with low frequency noise sources with channel variation to create
fluctuating, dreamy note sequences.
**** An Instrument
One may patch the ~RATE~ port with a VOCT signal, and the ~PLAY~ port with a
GATE signal, patch the output VCA with a GATE controlled envelope, and play
~GKO~ as if it were an instrument.

This use case applies to all the additional use cases below.

**** Wonky Audio Playback Unit
One may patch the ~RATE~ port to modulate the speed of playback and recording,
and one may patch the ~POS~ port to modulate the offset of ~GKO~ layers.
Using these, one could get some cool sounds with ~GKO~ - especially if there
is variation across channels. Have you ever wondered what playing back speech
with a sin wave sounds like? I have.

**** Wavetable Oscillator with Additive and Subtractive Synthesis Capabilities
~GKO~ can be a wavetable oscillator if either the ~PHASE~ rate is high, 

In this use case, the ~VERSION~ parameter morphs between recorded waves, and the
~DELTA~ parameter would add or subract from a ~VERSIONs~ wave.
** GKO Expansion Modules
*** SIGNAL
~SIGNAL~ takes an arbitrary signal as input, sends it to
~GKO~, and outputs a mix of the input signal and output from ~GKO~.

It also outputs ~GKO~'s selected layer(s). This is useful in the case of
applying audio functions (or signal functions) to particular layers in
~GKO~. To do this, one would select a layer, route ~SEL~ into other VCV Rack
modules, route the output of those modules back into the input, and modify the
layer by engaging recording in /layer/ mode.

**** MIX
- At 7 O'clock, ~SIG~ only outputs ~GKO~ output, and the input signal is fully
  attenuated. This is useful to control the input power, but also in the case multiple expansion modules exist so to not record this input signal when ~GKO~ enters a record mode.
- At 12 O'clock, the input signal is not attenuated.
- At 5 O'clock, the input signal is still not attenuated, and ~SIG~ outputs 100% of
  ~GKO~'s /active layer/. Used for auditioning multiple takes that were loop
  recorded, and for using /layer/ mode without sonic clutter from other layers.
**** VCA
A VCA for the output. Used for setting or modulating the output volume.
*** 4SIGNAL
~4IGNAL~ is ~SIGNAL~, just with 4 ports instead of 1. Its used for capturing
multiple signals, as it saves space compared to 4 ~SIGNAL~ modules set side by
side.
*** PLAY~ 
takes 3 signals associated with MIDI recording as input.

~PLAY~ functions just like ~SIG~, with a difference in how it attenuates signals.
Attenuation only affects VEL (velocity) signals until max attenuation, where it
also removes GATE signals and holds VOCT signals.

** TIMELINE

* Macro Modules 
a macro is a strip of modules that have parameter values, inputs, and outputs. 
The parameter values, and input and output ports are defined through the ~M-~ modules. 
One is able to save/load macros.
One is able to send macro outputs to macro inputs without using cables. This is so one may send
between [-100%, 100%] of a signal to a port without involving large matrices, and also so that
multiple macro out ports may be routed to the same in port with intuitive summing behaviour (e.g.
don't sum pitch, keep gates at 0 or 10v, saturate audio, hard clip cv). having control over routing
like this allows for routing to be recorded by ~GKO~.

The ~M-~ modules stay when one loads a new macro so that one can swap out macros and preserve the
connections on the input and output ports. 
This allows one to create macros of a particular type (e.g. audio FX, modulation source, sound
source, sound source player), and audition different ones quickly.

~MACRO~ is also expandable by ~GKO~, in which case, ~GKO~ will record and playback the output of the Macro, the parameter
values, parameter changes, the routing of the output, as well as which macro is loaded. 

After this is done, one can record new layers, optionally changing the macro to something else. 
Later on, one would be able to select the previously recorded layer through ~GKO~, and it will revert
to the macro, parameter values, outputs, and parameter changes, at the time of recording.
This allows one to adjust the aspects involved in the production of previously recorded layers.

** [#B] MACRO
Defines a macro. A macro consists of one or multiple ~M-PARAM~, and ~M-IN~ modules,
a strip of modules that follow it, and one or multiple ~M-OUT~ modules after the
strip, which end by touching the ~MACRO~ module.

User can enter a name for the macro, and save to file similar
to stoermelders ~STRIP~. The user can also use it to load macro files.

** M-PARAM
8 parameter mapping slots, with a place to enter an optional alias for the
parameter.

These mappings define the parameters of a macro.

Placed on the left side of a strip of modules.

** M-OUT
8 in ports, with place to enter names, as well as labels about type of signal
- gates (blue), clks (purple), triggers (light blue), control (yellow), audio
  (red), voct (green)

These ports define the output of the macro. they can be routed to any
~M-IN~ module by selecting one or multiple ports, and twisting the knob of the ~M-IN~ port either 100%
to the right (send 100% of the signal) or full left (send -100% of the signal). When a port is
selected, each ~M-IN~ module knobs is updated to reflect that ports send to that port.

Placed on the right side of a strip of modules.

** M-IN
8 out ports, with place to enter names, as well as labels about type of signal.

These ports define the inputs for a macro. The signal on them can come from any ~M-OUT~ module.

Placed on the left side of a strip of modules.
* OSC Interface Modules
** INTERFACE
The user inputs an address where it will listen for OSC messages from the controller. 

It will be able to:
- control the values of ~M-PARAM~ modules. (macro parameters)
- control the routings between ~M-OUT~ and ~M-IN~ modules. (macro routing)
- change macro of ~MACRO~ module (macro switching)
- select which macros ~GKO~'s are active with ~GKO-MUX~ module. (arming recording for selected macros)
- use ~GKO~ controls on ~GKO-MUX~ module (record (and other things) )
- control ~TIME~ module

It will receive data for display:
- names of macro parameters
- parameter values of macros
- names of macros
- routing between macros
- timeline data
- which macros are available to load
- gko information

TODO Should the messages follow a custom protocol that control Macro's, the Gko-Mux module, and the Time
module? Or should it be generic signals and no 'under the hood' controls, just parameter mapping and cables?
