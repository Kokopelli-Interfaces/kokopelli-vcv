* Myrisa Modules
** Modules For Structure
These modules, provide the ability to record, loop, edit, playback, and sequence
signals. I designed the interface for fluidity and simple controls, making them
suitable for live recording where one can not pause to click and clack.

The signal captured may be audio, in which case, these modules act as a loop
recorder that can create multi-layered musical sections, and then sequence these
sections. If capturing control voltage one could use these to record 
and sequence parameter automation, or as a keyframer. 


[[file:img/structure_modules.png]]


*** FRAME
The function of ~FRAME~ is to record and loop the input signals of the modules on
it's left. These modules - ~PLAY~, ~SIGNAL~, and ~SIGNAL4~, - define the inputs and
outputs of ~FRAME~. One can place multiple side by side to introduce more inputs
and outputs.

Despite the simple interface, one can use ~FRAME~ as a multi-track looper, a
sequencer for musical sections, a delay unit, a sample & hold unit, a sequencer,
and more! 

There is also a non input-output expander for ~FRAME~ called ~FRAME-X~. This module
provides additional ~RATE~ and ~POS~ parameters, as well as additional control
ports.  It enables more creative ways to use ~FRAME~.

~FRAME~ supports [[https://vcvrack.com/manual/Polyphony][polyphonic]] input.

**** Scene Selection
A scene is simply a collection of looping buffers, or, in frame's terminology, a
collection of 'layers'.

The ~SCENE~ parameter adjusts which scene ~FRAME~ records and reads from.

If ~SCENE~'s position is between two scenes, the behaviour will depend on the
"scene transition" option. 
- If set to  'smooth' it will output a weighted mix of both scenes, allowing for smooth crossfading between scenes. 
- If set to 'discrete', the scene will snap to the nearest scene. 
- If  set to 'sequence', the scene will snap to the nearest scene at the next
  clk step, and will also play the scene on transitioning. 

The port directly under ~SCENE~ modulates the parameter, allowing for
interesting crossfade patterns, or voltage controlled scene sequencing.

One may use multiple ~SCENEs~ to sequence musical sections or, in the case ~FRAME~
is capturing control voltage, a keyframer for control voltage.

Scenes that have not recorded anything start with the layers of the scene
before, so one may progress to the next scene to leave behind a 'checkpoint',
that one may return to, or to just start developing a new scene by altering the
current one.

**** Recording with FRAME 
When ~DELTA~ has moved a small threshold away from 12 o'clock, ~FRAME~ will
start recording. The scene that ~FRAME~ chooses for recording, is the scene that
is closest to the sum of the ~SCENE~ parameter and ~SCENE~ port.

If ~FRAME~ detects a clock signal on the ~CLK~ port, it will snap the  recording start
and end points to mutiples of the clock period. 

Recording behaviour depends on whether ~FRAME~ is in /global/ mode, or /layer/
mode. The ~DELTA_MODE~ button (up-right of ~DELTA~) toggles between these modes.
The lower LED in the delta section indicates its state.

Recording behaviour also depends on the direction of ~DELTA~'s rotation. If it
moves clockwise, it activates the /extend/ record mode. If ~DELTA~ moves
counter-clockwise, it activates /add/ mode. When ~DELTA~ returns to 12 o'clock,
~FRAME~ finishes recording. The upper LED in the delta section indicates the
current recording mode.

The record and delta modes create four recording behaviours when combined.
***** Recording Behaviours
****** /global/ and /extend/ mode
~FRAME~ records the input signal into a new buffer, and loops the buffer when
~DELTA~ returns to 12 o'clock.

Used for dubbing a loop with elements that are longer than the current loop
length - for example, adding a chord progression for a repeating phrase.
****** /global/ and /add/ mode
~FRAME~ records the input signal into a new buffer with the same length as the
active buffer. On reaching the end, it repeats the process.

Used for continuously recording multiple takes to audition and filter later
on, or record new layers continuously.
  
****** /layer/ and /extend/ mode
  ~FRAME~ records the input signal into the active buffer, and upon reaching the
  end, will continue recording as well as extend the active buffer by looping
  the old contents.

  Used for creating variation at the xth repetition of a buffer.
****** /layer/ and /add/ mode
~FRAME~ records the input signal into the active buffer and when it reaches the
loop end, it repeats the process.

Used for continuously overdubbing a buffer.
***** Buffer Attenuation
In all four mode combinations, if one twists further than the threshold
position, it affects the amplitude of previous buffers at the current position,
or in other words, the 'attenuation power' of the recording. If delta mode is
/layer/, it only attenuates the active buffer, if delta mode is /global/, it
attenuates all buffers.

The attenuation power grows exponentially as ~DELTA~ twists, and when it reaches
a maximum, it will erase previous buffers.

This attenuation behaviour allows for easily 'pushing back' previous layers in a
live-looping performance to create more movement, and also, to create
attenuation envelopes or erase parts of previous layers.

**** Button Behaviour
Excluding the ~DELTA_MODE~ button, there are four other buttons on ~FRAME~.

The button to the upper left of ~DELTA~ is the ~UNDO~ button. ~FRAME~ keeps
track of states before and after engaging record modes, and ~UNDO~ recalls the
previous states. When one presses ~UNDO~ in a record mode, ~FRAME~ will discard
any changes, and try again on the next loop start of the selected layer.

The ~LEFT~ and ~RIGHT~ buttons change the active buffer, and the ~PLAY~ button
resets all buffer positions to the beginning.
**** FRAME Additional Uses Cases
***** Delay Unit
~FRAME~ can function as a delay unit in the case /add/ mode is consistently on
in /layer/ mode. ~DELTA~ would control the feedback in this case.

One may use ~FRAME-X~ to change the rate and offset of the delays to produce
cool delay effects.

*** FRAME Expansion Modules
**** SIGNAL
~SIGNAL~ takes a polyphonic (or monophonic) signal as input, sends it to
~FRAME~, and outputs a mix of the input signal and output from ~FRAME~.

It also outputs ~FRAME~'s active/selected buffer. This is useful in the case of
applying audio functions or (control voltage functions) to particular buffers in
~FRAME~. To do this, one would select a buffer, route ~BUF~ into other VCV Rack
modules, route the output of those modules back into the input, and modify the
buffer by engaging recording in /layer/ mode.

***** MIX
- At 7'oclock, ~SIG~ only outputs ~FRAME~ output, and the input signal is fully
  attenuated. This is useful to control the input power, but also in the case multiple expansion modules exist so to not record this input signal when ~FRAME~ enters a record mode.
- At 12'oclock, the input signal is not attenuated.
- At 2:30, the input signal is still not attenuated, and ~SIG~ outputs 100% of
  ~FRAME~'s /active buffer/. Used for auditioning multiple takes that were loop
  recorded, and for using /layer/ mode without sonic clutter from other layers.
- Past 2:30, ~SIG~ will attenuate the input signal until it is fully attenuated at  5'oclock (max cw).
***** VCA
A VCA for the output. Used for setting or modulating the output volume.
**** 4SIGNAL
~4IGNAL~ is ~SIGNAL~, just with 4 ports instead of 1. It's used for capturing
multiple signals, as it saves space compared to 4 ~SIGNAL~ modules set side by
side.
**** PLAY
~PLAY~ takes 3 polyphonic (or monophonic) signals associated with MIDI recording
as input.

~PLAY~ functions just like ~SIG~, with a difference in how it attenuates signals.
Attenuation only affects VEL (velocity) signals until max attenuation, where it
also removes GATE signals and holds VOCT signals.

**** FRAME-X
This module is an expander for ~FRAME~. When placed on its right side, it gives
it extra ~RATE~, and ~POS~ parameters, as well as ports for controlling ~PREV~,
~NEXT~, and ~PLAY~.

This module enables more ways to use ~FRAME~, checkout the footnotes section if
interested.

The ~POS~ parameter controls the start offset of the buffers in the scene.

The ~RATE~ parameter controls the speed at which ~FRAME~ plays back the buffers
in the scene.

All the button ports react to rising edges. The ports underneath ~POS~ and
~RATE~ modulate the parameters.
***** FRAME-X Usage Ideas
****** Pitch Shifter
When one sets up ~FRAME~ as a delay unit with a small buffer size and adjusts
the ~RATE~ of ~FRAME-X~, it will seem like the pitch of the sound is higher or
lower.

****** Advanced Sample & Hold / Sequencer
When one sets ~RATE~ to 0, ~FRAME~ does not progress at all but still may record
and read signals. In this case, it acts as an advanced sample and hold module.
Adjusting the ~SCENE~ knob smoothly transitions between samples.

One may sequence samples in interesting ways using the ~SCENE~ modulation port.
****** Advanced MIDI Looper
When ~FRAME~ is expanding ~PLAY~, one may create interesting playback patterns
by recording some GATE, VOCT, and VEL signals, and varying or modulating the
~RATE~ and ~POS~ ports. One idea is to record a chord, and modulate ~RATE~ and
~POS~ with low frequency noise sources with channel variation to create
fluctuating, dreamy note sequences.
****** MIDI Instrument
MIDI keyboards output VOCT (pitch) and GATE signals.

One may patch the ~RATE~ port with a VOCT signal, and the ~PLAY~ port with a
GATE signal, patch the output VCA with a GATE controlled envelope, and play
~FRAME~ as if it were an instrument.

This use case applies to all the additional use cases below.

****** Wonky Audio Playback Unit 
One may patch the ~RATE~ port to modulate the speed of playback and recording,
and one may patch the ~POS~ port to modulate the offset of ~FRAME~ buffers.
Using these, one could get some cool sounds with ~FRAME~ - especially if there
is variation across channels. Have you ever wondered what playing back speech
with a sin wave sounds like? I have.

****** Wavetable Oscillator with Additive and Subtractive Synthesis Capabilities
~FRAME~ can be a wavetable oscillator if either the ~CLK~ rate is high, or a
high frequency saw wave is input into ~POS~.

In this use case, the ~SCENE~ parameter morphs between recorded waves, and the
~DELTA~ parameter would add or subract from a ~SCENEs~ wave.
****** Granular Synthesis Engine Component
To use ~FRAME~ as a granulart synthesis engine component, one would record an
audio signal, then patch a constant polyphonic signal with channel variation
into ~POS~.

To create the grains, one would patch the ~VCA~ in ~SIGNAL~ with short, repeating
envelopes with phase variation across channels.

*** TIMELINE
TODO
** Modules for a Sound Interface
*** Context
**** VCV Rack and the Modern DAW
The core issue, is that VCV Rack provides an environment for sound design that is
superior to the modern DAW, but lacks features related to the creation of sound
structures. 

Sound design is superior in VCV Rack, as there is freedom in the use and flow of
signals. Visually speaking, signals in the DAW are of midi or audio type, and
flow from ends of a graph towards the root. Signals in VCV Rack, are of any
type, and the routing may be that of any graph.

From the perspective of a creator, it enables a language of sonic relationships
and patterns. One could, for example, control the timber of two seperate sound
sources with a control signal generated from a simulated pendulum.

In addition to this freedom, VCV Rack modules has the capability to run VSTs via
the [[https://vcvrack.com/Host][VCV-HOST]] module, and VCV Rack also has a growing library of over 2000 other
modules.

Due to these points, the sound creation possibilities of VCV Rack are much
greater than that of the DAW.

The downside of VCV Rack, is that it lacks features related to the
creation of sound structures (compositions). There are a couple of [[https://www.youtube.com/watch?v=i3I_prfgZis][workflows, and tricks]], as
well as existing [[https://library.vcvrack.com/Entrian-Sequencers][modules]], to add structure to VCV Rack patches, though most are
lacking in their interface, as well as features.

One common issue in these workflows is that for larger compositions, the amount
of modules required goes up, as well as CPU usage and visual clutter. A
potential workflow to overcome this issue would be to record the audio output of
modules multiple times, and to then sequence the volume of these recordings, and
although this would overcome the CPU and visual clutter issue, one would be
unable to adjust the aspects involved in the production of previously produced
audio.

**** Where is the interface for the creator?
Workflows for composition aside, a key point is that both the interface for
modern DAWs and VCV Rack seem to have been designed from the perspective of an
engineer, not the perspective of a sound creator. Most importantly, there is no
emphasis on the real-time aspect of capturing creativity. The speed at which
sounds and sound structures heard in the mind may be realized in the world is
slow; there are frequent interruptions where one must click and clack to create
and arm new tracks, set up new instruments, or patch new modules.

There are interfaces for capturing sound structures that consider this real-time
aspect, such as [[https://forum.cockos.com/showthread.php?t=233734][wayback]], or hardware units such as the [[https://www.youtube.com/watch?v=PffyRrUEPVM][digitakt]]. Though all of
them either impose sonic restrictions, or lose some of the essential features
related to sound structure composition. One feature that is particularly
lacking, is a timeline that produces determinstic playback, that one may move
around in and add, adjust, or remove parameter automation, sound sources, and
fx.

*** Purpose of the Sound Interface 
The purpose of the SI is to provide a sound and sound structure creation
interface that holds the creator paramount, and has both the versatile sound
production capabilities of VCV Rack, and the essential sound structure features
of a Modern DAW.

Holding the creator paramount would mean minimal interruption of creative
flow, realtime sound and sound structure creation, lack of sonic restrictions,
as well as comfort and ease of use.

Since the SI has the versatile sound production capabilities of VCV Rack, it
will be able to adapt to the needs of any user. One could be a guitarist looking
for an fx rack, a beatboxer who needs a live-looping solution for live shows, a
band member who records and loops other bandmates instruments and applies fx to
them, a keyboard player looking for a versatile synthesizer, or a music goblin
that stays in his room for weeks at a time who believes his primary purpose in
life is to realize the sound structures that appear in his head (aka me).

This versatility of sound creation is why I think this project has potential. It
would be able to adapt to produce the same sounds as most music hardware
collections, without the hefty price tag. Think of the thousands spent on audio
creation and fx units - the modular synthesizers, guitar pedal boards, keyboard
synthesizers... why not have one common interface for sound creation, instead of
buying the 9th synthesizer keyboard for a [[https://www.reddit.com/r/synthesizercirclejerk/comments/i6ghli/started_with_the_minibrute_about_4_months_agobeen/][studio]]?

The Sound Interface will be a seperate from VCV Rack's interface, and may take
many forms. To start off, a touchscreen tablet or laptop running OpenOSC will
work, but later on, one could create a physical controller. No matter the form,
it will work by communicating via OSC with a set of modules running in VCV Rack
that will handle signal routing, parameter adjustement, module management, as
well as recording. Optimally, the interface will be able to replace the current
computer interface entirely, so one could just have the sound interface in front
of them and be able to create full songs (as well as optionally a midi keyboard,
midi controllers, microphones ... etc).
*** TODO The User Experience
Note, this section is a work in progress. It's lacking a lot of pictures too.
For now, I'm just implementing the modules for structure section, and will work
on this part in the future.  It mostly just contains notes  for myself right now.

**** Creating Sounds
***** Macros
The base block of sound generation in the SI is the /macro/. A macro is
a strip of modules (or single module) in VCV Rack that has associated inputs,
parameter values, and outputs. A set  of  'macro' modules will be made so one
can create these macros. 

The interface primarily consists of  'macro blocks' , and the user spends
most of his time adjusting these blocks. Macro blocks are controllers for macros
running in VCV Rack. Multiple macros may be stacked on the same macro block
position to save space, and switched between using the bottom arrow buttons (TODO).

Macro blocks have a mechanism to change the macro, knobs to adjust the parameter
values of macros, and arrow buttons for changing which macro parameters are
currently displayed. The central knob in the macro is the main macro knob, and
does not change on switching active macro parameters. 

One may also press the name of a macro parameter to activate /send mode/ for that
knob. The parameter name changes to the output name, and the values as well as
the names of other macro knobs are updated to display the 'send power' of the
activated knob to that knob, as well as the name of the input. One may twist the
knobs to send more and more of the activated knobs output signal to the knobs
associated in port. When fully twisted to the right, 100% of the signal is sent,
when fully twisted to the left, -100% of the signal is sent. Pressing the
activated knob name again exits send mode. This is how the SI accomplishes
signal routing. No cables, just press, twist another knob, and release.

***** Macro Creation
Macros are made with a set of macro creation modules in VCV Rack. They are then
saved into a folder, and then they can be selected by a macro block.

If the user is comfortable with modular synthesizers, they may create their own
macros for use. For less comfortable users, there will be provided macros, and
collections for particular use cases. In the future, a platform for the
downloading and sharing of macros would be a useful thing.

**** Macro Modules
***** Macro Modules
****** MACRO
Defines a macro. A macro consists of one or multiple ~M-PARAM~, and ~M-IN~ modules,
a strip of modules that follow it, and one or multiple ~M-OUT~ modules after the
strip, which touch the ~MACRO~ module.

User can enter a name for the macro, and save to file similar
to stoermelders ~STRIP~. The user can also use it to load macro files. 

****** M-PARAM
8 parameter mapping slots, with a place to enter an optional alias for the
parameter.

These mappings define the parameters of a macro.

Placed on the left side of a strip of modules.

****** M-OUT
8 in ports, with place to enter names, as well as labels about type of signal
- gates (blue), clks (purple), triggers (light blue), control (yellow), audio
  (red), voct (green)
  
These ports define the output of the macro. they can be routed via OSC to any
~M-IN~ module, as well as recorded via a ~FRAME~ like interface.

Placed on the right side of a strip of modules.

****** M-IN
8 out ports, with place to enter names, as well as labels about type of signal.
  
These ports define the inputs for a macro. The signal on them can come from any ~M-OUT~ module.

Placed on the left side of a strip of modules.

***** OSC / Sound Interface Module
This  module is the brains of the Sound Interface. The user inputs an address
where it will listen for OSC messages from the controller. It will react to
these messages and do multiple tasks, such  as 
- control the routings between ~M-OUT~ and ~M-IN~ modules. (control macro routing)
- control the values of ~M-PARAM~ modules. (control macro parameters)
- record and loop ~M-OUT~ module outputs ('frame' macros)
- intelligently disable modules that have a recording downstream of
  the routing graph.
- change active macros
- control the timeline

**** Structure Ideas & Notes WIP
***** Macro Modules
***** The Signal Graph
- Global and layer mode as well, either inter-macro routing or
  inter-layer routing
- connections have colors according to output types, and opacity according to
  power of send
***** DELTA behaviour
The DELTA knob handles all of the recording, dubbing, extending, 
attenuation, and erasing in the SI.

What the DELTA knob records, depends on the current state of the SI.
- If a macro knob is in send mode, the DELTA knob will record the output of that
  knob. Using this, one could record one part of a layer, such as a midi
  keyboard macro, or an audio input macro, and then adjust parameters, add
  automation, and etc.
- If the interface is in /layer/ mode, it will record the layers parameters,
  parameter changes, and layer outputs. Attenuation does not affect layer
  parameters, only layer outputs. TODO Question: allow overdubbing for layer outputs? This
  complicates things, how does one adjust previous overdubs? Will there be a
  concept of layer dubs, that one may cycle through? One would have to save the
  entire layer state each time.

How the SI records the macro output depends on the type of the output - for

example, it will not attenuate GATE signals.

***** Concepts
The interface achieves recording by applying the concepts of the ~FRAME~ module to the
entire state of the interface. 

I name this functionality the 'interface frame', and I will go over how the
concepts from ~FRAME~ transfer over.

****** Layers
A layer corresponds to one recorded instance of the interface. The recording
contains macro parameter values, macro routing to macros in the current layer,
macro routing to macros in other layers, (TODO?) macro routing to the global layer, as
well as the outputs of macros.

****** Global And Layer Mode
****** The Delta Parameter
Recording, dubbing, erasing, and extending loops is all done through just /one/
parameter - the ~DELTA~ parameter. The behaviour is conceptually identical to that
of ~FRAME~'s ~DELTA~ parameter.

When the recording loops, the outputs of the macros as well as the knob values
loop. Knobs in the interface reflect the current values of the recording, so
they may morph in time if one recorded such morphing.

The attenuation feature of ~DELTA~ in /layer/ mode only attenuates recordings of
macro outputs, not parameter values or routing values (a.k.a knob values). In
/global/ mode, attenuation affects the currently selected layers outputs (TODO?

When one alters knob values in read mode, it sets the offset for the knob value. When
one alters knob values in a record mode, it records the relative position of the
knob from the offset position.

Knob recording behaviour is similar to 'latch and arm' automation in DAWs. To
erase knob recordings, one enters a record mode, returns the knob to the offset
position, and waits for the duration of the loop. One may alter knob recordings
by temporarily engaging a record mode, recording knob movement, and exiting.

****** Scenes
Recall that in ~FRAME~ a 'scene' is a collections of layers, and one may use
the ~SCENE~ parameter to cross-fade between scenes or to sequence scene's. 
The scene feature in the interface frame includes this functionality, though it
only works when the interface frame is in /global/ mode. This is because there are
now ~SCENE~ values associated with not only the global context, but for each layer
as well. 

Using ~SCENE~ in /layer/ mode enables recording multiple takes of a particular
layer, smooth morphing between two interface states, saving and comparing patch states

it also has a seperate value associated with each layer. 

# how to record automation of scene for a layer?

***** User Steps To Record 
1. Adjust the layers macro's, macro parameters, and macro routing.
2. Activate /extend/ mode via ~DELTA~ to record the layer.
When recording,

***** Visual
***** The Various Scope's of the Interface
- interface controls adapt to scope, the visuals adapt to scope as well
- LAYER, SCENE and DELTA adapt to scope
  - reflects the cocentric circles structure of reality!
****** sends scope
activated when a knob is in send mode
scene: sequence recording
layer: change take
delta: extend or dub the knobs send
****** layer scope
activated by default, affects selected layers.
select all layers to create the global mode from ~FRAME~
scene: change layers
layer: change between different takes of the selected layers
delta: extend or dub the 

****** time scope
scene: move between entire songs
layer: move between different versions of the same song
delta:  extend or dub the timeline

***** Interface Timeline
Similar to there being an interface frame, there is also an interface timelines.

- timeline is a sequencer for the interface-frame's state as well as it's parameters.
- on scene transition, have scenes play from the start. this  will avoid inter
  scene desync,  
- moving the timeline also moves the playback position of the scene, so to
  enable reproducible playback
  - note, that the 'enter recording and change parameters' feature will not work
    with modules that have some concept of state - this state may desync with
    the layer output as the timeline scrubs.

***** Notes  & Questions
****** should there be a concept of global modules? somewhat equivalent to master
  track modules? or should there just be a layer all modules are routed to?
  + having a layer that is consistenly on the tree graph would produce clutter
  + imposing opinions is bad
  + 

-
